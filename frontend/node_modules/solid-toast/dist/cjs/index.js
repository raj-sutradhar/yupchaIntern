'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var solidJs = require('solid-js');
var store$1 = require('solid-js/store');
var web = require('solid-js/web');

const isFunction = valOrFunction => typeof valOrFunction === 'function';

const resolveValue = (valOrFunction, arg) => isFunction(valOrFunction) ? valOrFunction(arg) : valOrFunction;

exports.ActionType = void 0;

(function (ActionType) {
  ActionType[ActionType["ADD_TOAST"] = 0] = "ADD_TOAST";
  ActionType[ActionType["UPDATE_TOAST"] = 1] = "UPDATE_TOAST";
  ActionType[ActionType["UPSERT_TOAST"] = 2] = "UPSERT_TOAST";
  ActionType[ActionType["DISMISS_TOAST"] = 3] = "DISMISS_TOAST";
  ActionType[ActionType["REMOVE_TOAST"] = 4] = "REMOVE_TOAST";
  ActionType[ActionType["START_PAUSE"] = 5] = "START_PAUSE";
  ActionType[ActionType["END_PAUSE"] = 6] = "END_PAUSE";
})(exports.ActionType || (exports.ActionType = {}));

const [store, setStore] = store$1.createStore({
  toasts: [],
  pausedAt: undefined
});
const createTimers = () => {
  const {
    pausedAt,
    toasts
  } = store;
  if (pausedAt) return;
  const now = Date.now();
  const timers = toasts.map(toast => {
    if (toast.duration === Infinity) return;
    const durationLeft = (toast.duration || 0) + toast.pauseDuration - (now - toast.createdAt);

    if (durationLeft <= 0) {
      if (toast.visible) {
        dispatch({
          type: exports.ActionType.DISMISS_TOAST,
          toastId: toast.id
        });
      }

      return;
    }

    return setTimeout(() => {
      dispatch({
        type: exports.ActionType.DISMISS_TOAST,
        toastId: toast.id
      });
    }, durationLeft);
  });
  return timers;
};
const removalQueue = new Map();

const scheduleRemoval = (toastId, unmountDelay) => {
  if (removalQueue.has(toastId)) return;
  const timeout = setTimeout(() => {
    removalQueue.delete(toastId);
    dispatch({
      type: exports.ActionType.REMOVE_TOAST,
      toastId
    });
  }, unmountDelay);
  removalQueue.set(toastId, timeout);
};

const unscheduleRemoval = toastId => {
  const timeout = removalQueue.get(toastId);
  removalQueue.delete(toastId);
  if (timeout) clearTimeout(timeout);
};

const dispatch = action => {
  switch (action.type) {
    case exports.ActionType.ADD_TOAST:
      setStore('toasts', t => {
        const toasts = t;
        return [action.toast, ...toasts];
      });
      break;

    case exports.ActionType.DISMISS_TOAST:
      const {
        toastId
      } = action;
      const toasts = store.toasts;

      if (toastId) {
        const toastToRemove = toasts.find(t => t.id === toastId);
        if (toastToRemove) scheduleRemoval(toastId, toastToRemove.unmountDelay);
        setStore('toasts', t => t.id === toastId, store$1.produce(t => t.visible = false));
      } else {
        toasts.forEach(t => {
          scheduleRemoval(t.id, t.unmountDelay);
        });
        setStore('toasts', t => t.id !== undefined, store$1.produce(t => t.visible = false));
      }

      break;

    case exports.ActionType.REMOVE_TOAST:
      if (!action.toastId) {
        setStore('toasts', []);
        break;
      }

      setStore('toasts', t => {
        const toasts = t;
        return toasts.filter(t => t.id !== action.toastId);
      });
      break;

    case exports.ActionType.UPDATE_TOAST:
      if (action.toast.id) {
        unscheduleRemoval(action.toast.id);
      }

      setStore('toasts', t => t.id === action.toast.id, t => {
        const toast = t;
        return { ...toast,
          ...action.toast
        };
      });
      break;

    case exports.ActionType.UPSERT_TOAST:
      store.toasts.find(t => t.id === action.toast.id) ? dispatch({
        type: exports.ActionType.UPDATE_TOAST,
        toast: action.toast
      }) : dispatch({
        type: exports.ActionType.ADD_TOAST,
        toast: action.toast
      });
      break;

    case exports.ActionType.START_PAUSE:
      setStore(store$1.produce(s => {
        s.pausedAt = Date.now();
        s.toasts.forEach(t => {
          t.paused = true;
        });
      }));
      break;

    case exports.ActionType.END_PAUSE:
      const pauseInterval = action.time - (store.pausedAt || 0);
      setStore(store$1.produce(s => {
        s.pausedAt = undefined;
        s.toasts.forEach(t => {
          t.pauseDuration += pauseInterval;
          t.paused = false;
        });
      }));
      break;
  }
};

const defaultTimeouts = {
  blank: 4000,
  error: 4000,
  success: 2000,
  loading: Infinity,
  custom: 4000
};
const defaultToastOptions = {
  id: '',
  icon: '',
  unmountDelay: 500,
  duration: 3000,
  ariaProps: {
    role: 'status',
    'aria-live': 'polite'
  },
  className: '',
  style: {},
  position: 'top-right',
  iconTheme: {}
};
const defaultToasterOptions = {
  position: 'top-right',
  toastOptions: defaultToastOptions,
  gutter: 8,
  containerStyle: {},
  containerClassName: ''
};
const defaultContainerPadding = '16px';
const defaultContainerStyle = {
  position: 'fixed',
  'z-index': 9999,
  top: defaultContainerPadding,
  bottom: defaultContainerPadding,
  left: defaultContainerPadding,
  right: defaultContainerPadding,
  'pointer-events': 'none'
};

const generateID = (() => {
  let count = 0;
  return () => String(++count);
})();
const mergeContainerOptions = props => {
  setDefaultOpts(s => ({
    containerClassName: props.containerClassName ?? s.containerClassName,
    containerStyle: props.containerStyle ?? s.containerStyle,
    gutter: props.gutter ?? s.gutter,
    position: props.position ?? s.position,
    toastOptions: { ...props.toastOptions
    }
  }));
};
const getToastWrapperStyles = (position, offset) => {
  const top = position.includes('top');
  const verticalStyle = top ? {
    top: 0,
    'margin-top': `${offset}px`
  } : {
    bottom: 0,
    'margin-bottom': `${offset}px`
  };
  const horizontalStyle = position.includes('center') ? {
    'justify-content': 'center'
  } : position.includes('right') ? {
    'justify-content': 'flex-end'
  } : {};
  return {
    left: 0,
    right: 0,
    display: 'flex',
    position: 'absolute',
    transition: `all 230ms cubic-bezier(.21,1.02,.73,1)`,
    ...verticalStyle,
    ...horizontalStyle
  };
};
const updateToastHeight = (ref, toast) => {
  const boundingRect = ref.getBoundingClientRect();

  if (boundingRect.height !== toast.height) {
    dispatch({
      type: exports.ActionType.UPDATE_TOAST,
      toast: {
        id: toast.id,
        height: boundingRect.height
      }
    });
  }
};
const getWrapperYAxisOffset = (toast, position) => {
  const {
    toasts
  } = store;
  const gutter = defaultOpts().gutter || defaultToasterOptions.gutter || 8;
  const relevantToasts = toasts.filter(t => (t.position || position) === position && t.height);
  const toastIndex = relevantToasts.findIndex(t => t.id === toast.id);
  const toastsBefore = relevantToasts.filter((toast, i) => i < toastIndex && toast.visible).length;
  const offset = relevantToasts.slice(0, toastsBefore).reduce((acc, t) => acc + gutter + (t.height || 0), 0);
  return offset;
};
const getToastYDirection = (toast, defaultPos) => {
  const position = toast.position || defaultPos;
  const top = position.includes('top');
  return top ? 1 : -1;
};

const toastBarBase = {
  display: 'flex',
  'align-items': 'center',
  color: '#363636',
  background: 'white',
  'box-shadow': '0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05)',
  'max-width': '350px',
  'pointer-events': 'auto',
  padding: '8px 10px',
  'border-radius': '4px',
  'line-height': '1.3',
  'will-change': 'transform'
};
const messageContainer = {
  display: 'flex',
  'align-items': 'center',
  flex: '1 1 auto',
  margin: '4px 10px',
  'white-space': 'pre-line'
};
const iconContainer = {
  'flex-shrink': 0,
  'min-width': '20px',
  'min-height': '20px',
  display: 'flex',
  'align-items': 'center',
  'justify-content': 'center',
  'text-align': 'center'
};
const genSVGCubicBezier = keySplines => ({
  calcMode: 'spline',
  keyTimes: '0; 1',
  keySplines: keySplines
});

const [defaultOpts, setDefaultOpts] = solidJs.createSignal(defaultToasterOptions);
const createToast = (message, type = 'blank', options) => ({ ...defaultToastOptions,
  ...defaultOpts().toastOptions,
  ...options,
  type,
  message,
  pauseDuration: 0,
  createdAt: Date.now(),
  visible: true,
  id: options.id || generateID(),
  paused: false,
  style: { ...defaultToastOptions.style,
    ...defaultOpts().toastOptions?.style,
    ...options.style
  },
  duration: options.duration || defaultOpts().toastOptions?.duration || defaultTimeouts[type],
  position: options.position || defaultOpts().toastOptions?.position || defaultOpts().position || defaultToastOptions.position
});

const createToastCreator = type => (message, options = {}) => {
  return solidJs.createRoot(() => {
    const existingToast = store.toasts.find(t => t.id === options.id);
    const toast = createToast(message, type, { ...existingToast,
      duration: undefined,
      ...options
    });
    dispatch({
      type: exports.ActionType.UPSERT_TOAST,
      toast
    });
    return toast.id;
  });
};

const toast$1 = (message, opts) => createToastCreator('blank')(message, opts);

solidJs.untrack(() => toast$1);
toast$1.error = createToastCreator('error');
toast$1.success = createToastCreator('success');
toast$1.loading = createToastCreator('loading');
toast$1.custom = createToastCreator('custom');

toast$1.dismiss = toastId => {
  dispatch({
    type: exports.ActionType.DISMISS_TOAST,
    toastId
  });
};

toast$1.promise = (promise, msgs, opts) => {
  const id = toast$1.loading(msgs.loading, { ...opts
  });
  promise.then(p => {
    toast$1.success(resolveValue(msgs.success, p), {
      id,
      ...opts
    });
    return p;
  }).catch(e => {
    toast$1.error(resolveValue(msgs.error, e), {
      id,
      ...opts
    });
  });
  return promise;
};

toast$1.remove = toastId => {
  dispatch({
    type: exports.ActionType.REMOVE_TOAST,
    toastId
  });
};

const _tmpl$$6 = /*#__PURE__*/web.template(`<div><style>.sldt-active{z-index:9999;}.sldt-active>*{pointer-events:auto;}</style></div>`, 4);
const Toaster = props => {
  solidJs.createEffect(() => {
    mergeContainerOptions(props);
  });
  solidJs.createEffect(() => {
    const timers = createTimers();
    solidJs.onCleanup(() => {
      if (!timers) return;
      timers.forEach(timer => timer && clearTimeout(timer));
    });
  });
  return (() => {
    const _el$ = _tmpl$$6.cloneNode(true);
          _el$.firstChild;

    web.insert(_el$, web.createComponent(solidJs.For, {
      get each() {
        return store.toasts;
      },

      children: toast => web.createComponent(ToastContainer, {
        toast: toast
      })
    }), null);

    web.effect(_p$ => {
      const _v$ = { ...defaultContainerStyle,
        ...props.containerStyle
      },
            _v$2 = props.containerClassName;
      _p$._v$ = web.style(_el$, _v$, _p$._v$);
      _v$2 !== _p$._v$2 && web.className(_el$, _p$._v$2 = _v$2);
      return _p$;
    }, {
      _v$: undefined,
      _v$2: undefined
    });

    return _el$;
  })();
};

const _tmpl$$5 = /*#__PURE__*/web.template(`<div></div>`, 2),
      _tmpl$2$1 = /*#__PURE__*/web.template(`<div><div></div></div>`, 4);
const ToastBar = props => {
  let el;
  solidJs.createEffect(() => {
    if (!el) return;
    const direction = getToastYDirection(props.toast, props.position);

    if (props.toast.visible) {
      el.animate([{
        transform: `translate3d(0,${direction * -200}%,0) scale(.6)`,
        opacity: 0.5
      }, {
        transform: 'translate3d(0,0,0) scale(1)',
        opacity: 1
      }], {
        duration: 350,
        fill: 'forwards',
        easing: 'cubic-bezier(.21,1.02,.73,1)'
      });
    } else {
      el.animate([{
        transform: 'translate3d(0,0,-1px) scale(1)',
        opacity: 1
      }, {
        transform: `translate3d(0,${direction * -150}%,-1px) scale(.4)`,
        opacity: 0
      }], {
        duration: 400,
        fill: 'forwards',
        easing: 'cubic-bezier(.06,.71,.55,1)'
      });
    }
  });
  return (() => {
    const _el$ = _tmpl$2$1.cloneNode(true),
          _el$6 = _el$.firstChild;

    const _ref$ = el;
    typeof _ref$ === "function" ? _ref$(_el$) : el = _el$;

    web.insert(_el$, web.createComponent(solidJs.Switch, {
      get children() {
        return [web.createComponent(solidJs.Match, {
          get when() {
            return props.toast.icon;
          },

          get children() {
            const _el$2 = _tmpl$$5.cloneNode(true);

            web.insert(_el$2, () => props.toast.icon);

            web.effect(_$p => web.style(_el$2, iconContainer, _$p));

            return _el$2;
          }

        }), web.createComponent(solidJs.Match, {
          get when() {
            return props.toast.type === 'loading';
          },

          get children() {
            const _el$3 = _tmpl$$5.cloneNode(true);

            web.insert(_el$3, web.createComponent(Loader, web.mergeProps(() => props.toast.iconTheme)));

            web.effect(_$p => web.style(_el$3, iconContainer, _$p));

            return _el$3;
          }

        }), web.createComponent(solidJs.Match, {
          get when() {
            return props.toast.type === 'success';
          },

          get children() {
            const _el$4 = _tmpl$$5.cloneNode(true);

            web.insert(_el$4, web.createComponent(Success, web.mergeProps(() => props.toast.iconTheme)));

            web.effect(_$p => web.style(_el$4, iconContainer, _$p));

            return _el$4;
          }

        }), web.createComponent(solidJs.Match, {
          get when() {
            return props.toast.type === 'error';
          },

          get children() {
            const _el$5 = _tmpl$$5.cloneNode(true);

            web.insert(_el$5, web.createComponent(Error, web.mergeProps(() => props.toast.iconTheme)));

            web.effect(_$p => web.style(_el$5, iconContainer, _$p));

            return _el$5;
          }

        })];
      }

    }), _el$6);

    web.spread(_el$6, () => props.toast.ariaProps, false, true);

    web.insert(_el$6, () => resolveValue(props.toast.message, props.toast));

    web.effect(_p$ => {
      const _v$ = props.toast.className,
            _v$2 = { ...toastBarBase,
        ...props.toast.style
      },
            _v$3 = messageContainer;
      _v$ !== _p$._v$ && web.className(_el$, _p$._v$ = _v$);
      _p$._v$2 = web.style(_el$, _v$2, _p$._v$2);
      _p$._v$3 = web.style(_el$6, _v$3, _p$._v$3);
      return _p$;
    }, {
      _v$: undefined,
      _v$2: undefined,
      _v$3: undefined
    });

    return _el$;
  })();
};

const _tmpl$$4 = /*#__PURE__*/web.template(`<div></div>`, 2);
const ToastContainer = props => {
  const calculatePosition = () => {
    const position = props.toast.position || defaultToastOptions.position;
    const offset = getWrapperYAxisOffset(props.toast, position);
    const positionStyle = getToastWrapperStyles(position, offset);
    return positionStyle;
  };

  const positionStyle = solidJs.createMemo(() => calculatePosition());
  let el = undefined;
  solidJs.onMount(() => {
    if (el) {
      updateToastHeight(el, props.toast);
    }
  });
  return (() => {
    const _el$ = _tmpl$$4.cloneNode(true);

    _el$.addEventListener("mouseleave", () => dispatch({
      type: exports.ActionType.END_PAUSE,
      time: Date.now()
    }));

    _el$.addEventListener("mouseenter", () => dispatch({
      type: exports.ActionType.START_PAUSE,
      time: Date.now()
    }));

    const _ref$ = el;
    typeof _ref$ === "function" ? _ref$(_el$) : el = _el$;

    web.insert(_el$, (() => {
      const _c$ = web.memo(() => props.toast.type === 'custom', true);

      return () => _c$() ? resolveValue(props.toast.message, props.toast) : web.createComponent(ToastBar, {
        get toast() {
          return props.toast;
        },

        get position() {
          return props.toast.position || defaultToastOptions.position;
        }

      });
    })());

    web.effect(_p$ => {
      const _v$ = positionStyle(),
            _v$2 = props.toast.visible ? 'sldt-active' : '';

      _p$._v$ = web.style(_el$, _v$, _p$._v$);
      _v$2 !== _p$._v$2 && web.className(_el$, _p$._v$2 = _v$2);
      return _p$;
    }, {
      _v$: undefined,
      _v$2: undefined
    });

    return _el$;
  })();
};

const _tmpl$$3 = /*#__PURE__*/web.template(`<svg><circle cx="16" cy="16" r="0"><animate attributeName="opacity" values="0; 1; 1"></animate><animate attributeName="r" values="0; 17.5; 16"></animate></circle></svg>`, 8, true),
      _tmpl$2 = /*#__PURE__*/web.template(`<svg><circle cx="16" cy="16" r="12" opacity="0"><animate attributeName="opacity" values="1; 0"></animate><animate attributeName="r" values="12; 26"></animate></circle></svg>`, 8, true);
const MainCircle = props => {
  const publicProps = {
    dur: '0.35s',
    begin: '100ms',
    fill: 'freeze',
    calcMode: 'spline',
    keyTimes: '0; 0.6; 1',
    keySplines: '0.25 0.71 0.4 0.88; .59 .22 .87 .63'
  };
  return (() => {
    const _el$ = _tmpl$$3.cloneNode(true),
          _el$2 = _el$.firstChild,
          _el$3 = _el$2.nextSibling;

    web.spread(_el$2, publicProps, true, false);

    web.spread(_el$3, publicProps, true, false);

    web.effect(() => web.setAttribute(_el$, "fill", props.fill));

    return _el$;
  })();
};
const SecondaryCircle = props => {
  const publicProps = {
    dur: '1s',
    begin: props.begin || '320ms',
    fill: 'freeze',
    ...genSVGCubicBezier('0.0 0.0 0.2 1')
  };
  return (() => {
    const _el$4 = _tmpl$2.cloneNode(true),
          _el$5 = _el$4.firstChild,
          _el$6 = _el$5.nextSibling;

    web.spread(_el$5, publicProps, true, false);

    web.spread(_el$6, publicProps, true, false);

    web.effect(() => web.setAttribute(_el$4, "fill", props.fill));

    return _el$4;
  })();
};

const _tmpl$$2 = /*#__PURE__*/web.template(`<svg viewBox="0 0 32 32" width="1.25rem" height="1.25rem"><path fill="none" stroke-width="4" stroke-dasharray="22" stroke-dashoffset="22" stroke-linecap="round" stroke-miterlimit="10" d="M9.8,17.2l3.8,3.6c0.1,0.1,0.3,0.1,0.4,0l9.6-9.7"><animate attributeName="stroke-dashoffset" values="22;0" dur="0.25s" begin="250ms" fill="freeze"></animate></path></svg>`, 6);
const Success = props => {
  const fill = props.primary || '#34C759';
  return (() => {
    const _el$ = _tmpl$$2.cloneNode(true),
          _el$2 = _el$.firstChild,
          _el$3 = _el$2.firstChild;

    _el$.style.setProperty("overflow", "visible");

    web.insert(_el$, web.createComponent(MainCircle, {
      fill: fill
    }), _el$2);

    web.insert(_el$, web.createComponent(SecondaryCircle, {
      fill: fill,
      begin: "350ms"
    }), _el$2);

    web.spread(_el$3, () => genSVGCubicBezier('0.0, 0.0, 0.58, 1.0'), true, false);

    web.effect(() => web.setAttribute(_el$2, "stroke", props.secondary || '#FCFCFC'));

    return _el$;
  })();
};

const _tmpl$$1 = /*#__PURE__*/web.template(`<svg viewBox="0 0 32 32" width="1.25rem" height="1.25rem"><path fill="none" stroke-width="4" stroke-dasharray="9" stroke-dashoffset="9" stroke-linecap="round" d="M16,7l0,9"><animate attributeName="stroke-dashoffset" values="9;0" dur="0.2s" begin="250ms" fill="freeze"></animate></path><circle cx="16" cy="23" r="2.5" opacity="0"><animate attributeName="opacity" values="0;1" dur="0.25s" begin="350ms" fill="freeze"></animate></circle></svg>`, 10);
const Error = props => {
  const fill = props.primary || '#FF3B30';
  return (() => {
    const _el$ = _tmpl$$1.cloneNode(true),
          _el$2 = _el$.firstChild,
          _el$3 = _el$2.firstChild,
          _el$4 = _el$2.nextSibling,
          _el$5 = _el$4.firstChild;

    _el$.style.setProperty("overflow", "visible");

    web.insert(_el$, web.createComponent(MainCircle, {
      fill: fill
    }), _el$2);

    web.insert(_el$, web.createComponent(SecondaryCircle, {
      fill: fill
    }), _el$2);

    web.spread(_el$3, () => genSVGCubicBezier('0.0, 0.0, 0.58, 1.0'), true, false);

    web.spread(_el$5, () => genSVGCubicBezier('0.0, 0.0, 0.58, 1.0'), true, false);

    web.effect(_p$ => {
      const _v$ = props.secondary || '#FFFFFF',
            _v$2 = props.secondary || '#FFFFFF';

      _v$ !== _p$._v$ && web.setAttribute(_el$2, "stroke", _p$._v$ = _v$);
      _v$2 !== _p$._v$2 && web.setAttribute(_el$4, "fill", _p$._v$2 = _v$2);
      return _p$;
    }, {
      _v$: undefined,
      _v$2: undefined
    });

    return _el$;
  })();
};

const _tmpl$ = /*#__PURE__*/web.template(`<svg viewBox="0 0 32 32" width="1.25rem" height="1.25rem"><path fill="none" stroke-width="4" stroke-miterlimit="10" d="M16,6c3,0,5.7,1.3,7.5,3.4c1.5,1.8,2.5,4,2.5,6.6c0,5.5-4.5,10-10,10S6,21.6,6,16S10.5,6,16,6z"></path><path fill="none" stroke-width="4" stroke-linecap="round" stroke-miterlimit="10" d="M16,6c3,0,5.7,1.3,7.5,3.4c0.6,0.7,1.1,1.4,1.5,2.2"><animateTransform attributeName="transform" type="rotate" from="0 16 16" to="360 16 16" dur="0.75s" repeatCount="indefinite"></animateTransform></path></svg>`, 8);

const Loader = props => (() => {
  const _el$ = _tmpl$.cloneNode(true),
        _el$2 = _el$.firstChild,
        _el$3 = _el$2.nextSibling;

  _el$.style.setProperty("overflow", "visible");

  web.effect(_p$ => {
    const _v$ = props.primary || '#E5E7EB',
          _v$2 = props.secondary || '#4b5563';

    _v$ !== _p$._v$ && web.setAttribute(_el$2, "stroke", _p$._v$ = _v$);
    _v$2 !== _p$._v$2 && web.setAttribute(_el$3, "stroke", _p$._v$2 = _v$2);
    return _p$;
  }, {
    _v$: undefined,
    _v$2: undefined
  });

  return _el$;
})();

var toast = toast$1;

exports.Toaster = Toaster;
exports["default"] = toast;
exports.resolveValue = resolveValue;
exports.toast = toast$1;
//# sourceMappingURL=index.js.map
